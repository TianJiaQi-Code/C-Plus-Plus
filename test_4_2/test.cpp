#include <iostream>
using namespace std;

//// 节点的颜色
//enum Color { RED, BLACK };
//// 红黑树节点的定义
//template<class ValueType>
//struct RBTreeNode
//{
//	RBTreeNode(const ValueType& data = ValueType()，Color color = RED)
//		: _pLeft(nullptr), _pRight(nullptr), _pParent(nullptr)
//		, _data(data), _color(color)
//	{}
//	RBTreeNode<ValueType>* _pLeft; // 节点的左孩子
//	RBTreeNode<ValueType>* _pRight; // 节点的右孩子
//	RBTreeNode<ValueType>* _pParent; // 节点的双亲(红黑树需要旋转，为了实现简单给出该字段)
//	ValueType _data; // 节点的值域
//	Color _color; // 节点的颜色
//};

//template<class ValueType>
//class RBTree
//{
//	//……
//	bool Insert(const ValueType& data)
//	{
//		PNode& pRoot = GetRoot();
//		if (nullptr == pRoot)
//		{
//			pRoot = new Node(data, BLACK);
//			// 根的双亲为头节点
//			pRoot->_pParent = _pHead;
//			_pHead->_pParent = pRoot;
//		}
//		else
//		{
//			// 1. 按照二叉搜索的树方式插入新节点
//			// 2. 检测新节点插入后，红黑树的性质是否造到破坏，
//			// 若满足直接退出，否则对红黑树进行旋转着色处理
//		}
//		// 根节点的颜色可能被修改，将其改回黑色
//		pRoot->_color = BLACK;
//		_pHead->_pLeft = LeftMost();
//		_pHead->_pRight = RightMost();
//		return true;
//	}
//private:
//	PNode& GetRoot() { return _pHead->_pParent; }
//	// 获取红黑树中最小节点，即最左侧节点
//	PNode LeftMost();
//	// 获取红黑树中最大节点，即最右侧节点
//	PNode RightMost();
//private:
//	PNode _pHead;
//};

//bool Insert(const ValueType& data)
//{
//	// ...
//	// 新节点插入后，如果其双亲节点的颜色为空色，则违反性质3：不能有连在一起的红色结点
//	while (pParent && RED == pParent->_color)
//	{
//		// 注意：grandFather一定存在
//		// 因为pParent存在，且不是黑色节点，则pParent一定不是根，则其一定有双亲
//		PNode grandFather = pParent->_pParent;
//		// 先讨论左侧情况
//		if (pParent == grandFather->_pLeft)
//		{
//			PNode unclue = grandFather->_pRight;
//			// 情况三：叔叔节点存在，且为红
//			if (unclue && RED == unclue->_color)
//			{
//				pParent->_color = BLACK;
//				unclue->_color = BLACK;
//				grandFather->_color = RED;
//				pCur = grandFather;
//				pParent = pCur->_pParent;
//			}
//			else
//			{
//				// 情况五：叔叔节点不存在，或者叔叔节点存在且为黑
//				if (pCur == pParent->_pRight)
//				{
//					_RotateLeft(pParent);
//					swap(pParent, pCur);
//				}
//				// 情况五最后转化成情况四
//				grandFather->_color = RED;
//				pParent->_color = BLACK;
//				_RotateRight(grandFather);
//			}
//		}
//		else
//		{
//			// 右侧请学生们自己动手完成
//		}
//	}
//	// ...
//}

bool IsValidRBTree()
{
	PNode pRoot = GetRoot();
	// 空树也是红黑树
	if (nullptr == pRoot)
		return true;
	// 检测根节点是否满足情况
	if (BLACK != pRoot->_color)
	{
		cout << "违反红黑树性质二：根节点必须为黑色" << endl;
		return false;
	}
	// 获取任意一条路径中黑色节点的个数
	size_t blackCount = 0;
	PNode pCur = pRoot;
	while (pCur)
	{
		if (BLACK == pCur->_color)
			blackCount++;
		pCur = pCur->_pLeft;
	}
	// 检测是否满足红黑树的性质，k用来记录路径中黑色节点的个数
	size_t k = 0;
	return _IsValidRBTree(pRoot, k, blackCount);
}
bool _IsValidRBTree(PNode pRoot, size_t k, const size_t blackCount)
{
	//走到null之后，判断k和black是否相等
	if (nullptr == pRoot)
	{
		if (k != blackCount)
		{
			cout << "违反性质四：每条路径中黑色节点的个数必须相同" << endl;
			return false;
		}
		return true;
	}
	// 统计黑色节点的个数
	if (BLACK == pRoot->_color)
		k++;
	// 检测当前节点与其双亲是否都为红色
	PNode pParent = pRoot->_pParent;
	if (pParent && RED == pParent->_color && RED == pRoot->_color)
	{
		cout << "违反性质三：没有连在一起的红色节点" << endl;
		return false;
	}
	return _IsValidRBTree(pRoot->_pLeft, k, blackCount)
		&& _IsValidRBTree(pRoot->_pRight, k, blackCount);
}